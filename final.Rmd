```{r}
library(tidyverse)
library(caret)
library(rpart)
library(RWeka)
library(kernlab)# for SVM
library(e1071) # also for SVM
library(randomForest)
library(RColorBrewer)
library(FSelector)#information.gain
library(caret)

library(RWeka)       # An R interface to Weka (Version 3.9.3). Weka is a collection of machine learning algorithms for data mining tasks written in Java, containing tools for data pre-processing, classification, regression, clustering, association rules, and visualization
library(party)       # A computational toolbox for recursive partitioning
library(partykit)    # A toolkit with infrastructure for representing, summarizing, and visualizing tree-structured regression and classification models.

# helper packages
library(readr)       # for data import
library(dplyr)       # for data wrangling
library(ggplot2)     # for awesome plotting

# modeling packages
library(rpart)       # direct engine for decision tree application
library(caret)       # meta engine for decision tree application

# model interpretations packages
library(rpart.plot)  # for plotting decision trees
library(vip)         # for feature importance
library(pdp) 
```

```{r}
csgo_round <- read.csv("csgo_round_snapshots.csv")
# glimpse(csgo_round)
```

# Data Cleaning

- Don't need money columns
- Don't need players_alive since we are only using first screenshot
- Don't need health since we are only using first screenshot where it's constant
- Group like weapons

# Determining Round Number

```{r}
# Find out when a new round starts
csgo_round <- csgo_round %>% mutate(round_num=case_when(time_left > lag(time_left, 1) & (time_left - lag(time_left) > 5.0) ~ 'New Round', TRUE ~ "Same Round")) %>% relocate(round_num, .before=time_left)

# The first row is always a new round
csgo_round[1,"round_num"] <- 'New Round'

# Delete columns we do not need
unwanted_cols <- c("round_num", "ct_money", "t_money", "ct_players_alive", "t_players_alive", "ct_money", "t_money", "time_left", "ct_health", "t_health")

csgo_round <- csgo_round[csgo_round$round_num == 'New Round',] %>% select(!all_of(unwanted_cols))

# Group weapons

all_grenades <- c("grenade_hegrenade", "grenade_flashbang", "grenade_smokegrenade", "grenade_incendiarygrenade", "grenade_molotovgrenade", "grenade_decoygrenade")

csgo_round$t_grenades <- rowSums(csgo_round[,paste0("t_", all_grenades)])
csgo_round$ct_grenades <- rowSums(csgo_round[,paste0("ct_", all_grenades)])

csgo_round <- csgo_round %>% select(-contains(all_grenades))

all_pistols <- c("weapon_glock", "weapon_usps", "weapon_p250", "weapon_tec9", "weapon_p2000", "weapon_fiveseven", "weapon_cz75auto", "weapon_deagle", "weapon_r8revolver", "weapon_elite")
special_pistols <- c("weapon_p250", "weapon_tec9", "weapon_fiveseven", "weapon_cz75auto", "weapon_deagle", "weapon_r8revolver", "weapon_elite")

csgo_round$t_pistols <- rowSums(csgo_round[,paste0("t_", special_pistols)])
csgo_round$ct_pistols <- rowSums(csgo_round[,paste0("ct_", special_pistols)])

csgo_round <- csgo_round %>% select(-contains(all_pistols))

all_shotguns <- c("weapon_nova", "weapon_xm1014", "weapon_mag7", "weapon_sawedoff")

csgo_round$t_shotguns <- rowSums(csgo_round[,paste0("t_", all_shotguns)])
csgo_round$ct_shotguns <- rowSums(csgo_round[,paste0("ct_", all_shotguns)])

csgo_round <- csgo_round %>% select(-contains(all_shotguns))

all_smgs <- c("weapon_mac10", "weapon_mp9", "weapon_ump45", "weapon_mp7", "weapon_bizon", "weapon_p90", "weapon_mp5sd")

csgo_round$t_smgs <- rowSums(csgo_round[,paste0("t_", all_smgs)])
csgo_round$ct_smgs <- rowSums(csgo_round[,paste0("ct_", all_smgs)])

csgo_round <- csgo_round %>% select(-contains(all_smgs))

all_rifles <- c("weapon_galilar", "weapon_famas", "weapon_ak47", "weapon_m4a4", "weapon_m4a1s", "weapon_sg553", "weapon_aug")

csgo_round$t_rifles <- rowSums(csgo_round[,paste0("t_", all_rifles)])
csgo_round$ct_rifles <- rowSums(csgo_round[,paste0("ct_", all_rifles)])

csgo_round <- csgo_round %>% select(-contains(all_rifles))

all_snipers <- c("weapon_ssg08", "weapon_awp", "weapon_g3sg1", "weapon_scar20")

csgo_round$t_snipers <- rowSums(csgo_round[,paste0("t_", all_snipers)])
csgo_round$ct_snipers <- rowSums(csgo_round[,paste0("ct_", all_snipers)])

csgo_round <- csgo_round %>% select(-contains(all_snipers))

all_machines <- c("weapon_m249", "weapon_negev")

csgo_round$t_machines <- rowSums(csgo_round[,paste0("t_", all_machines)])
csgo_round$ct_machines <- rowSums(csgo_round[,paste0("ct_", all_machines)])

csgo_round <- csgo_round %>% select(-contains(all_machines))

csgo_round <- csgo_round %>% relocate(round_winner, .after=last_col())

# Write the new data to a CSV
#write.csv(csgo_round, "csgo_test.csv")
```

# Making all character vectors into factors

```{r}
csgo_round <- csgo_round %>% mutate_if(is.character, as.factor)
csgo_round<-subset(csgo_round, select = -c(ct_score, t_score))
```

# Downsize simple

```{r}
set.seed(9)
csgo_round_ds<-sample_n(csgo_round,1000)

```


### Split into two dataframes, terrorist and counter-terrorist winners
```{r}
listed <- sapply(c("t_", "ct_"), function(x)
                 csgo_round[(startsWith(names(csgo_round), x)) |
                            (startsWith(names(csgo_round), "bomb_planted")) |
                            (startsWith(names(csgo_round), "round_winner")) |
                            (startsWith(names(csgo_round), "map")) |
                            (startsWith(names(csgo_round), "index"))],
                simplify=FALSE)
t_winners <- do.call("rbind", listed[1]) %>% filter(round_winner == "T")
rownames(t_winners) <- NULL
ct_winners <- do.call("rbind", listed[2]) %>% filter(round_winner == "CT")
rownames(ct_winners) <- NULL
```

# SVM Model

```{r, eval=FALSE}
################################################################################
# fit Support Vector Machine model


# read in saved model
svmfit = readRDS('svmfit.rds')

#svmfit = svm(round_winner ~ ., data = csgo_round_ds,
#             kernel = 'linear',
#             scale = FALSE)

pred.svm = predict(svmfit, newdata = csgo_round_ds)
confusionMatrix(pred.svm, csgo_round_ds$round_winner)


#save model
#saveRDS(svmfit, 'svmfit.rds')



################################################################################
#SVM with Linear Kernel


search.grid = expand.grid(C = seq(0.1, 2, length = 20))

# set up fold cross validation 
train.control = trainControl(
  method = 'repeatedcv', 
  number = 4
  )


# read in saved model
svm.m1 = readRDS('svm.m1.rds')

#svm.m1 = train(round_winner ~.,
#               data = csgo_round_ds,
#               method = 'svmLinear',
#               trControl = train.control,
#               tuneGrid = search.grid)


# results for the best model
confusionMatrix(svm.m1)


#save model
#saveRDS(svm.m1, 'svm.m1.rds')




################################################################################
# SVM with Polynomial Kernel(not run)



search.grid = expand.grid(degree = c(1, 2, 3),
                          scale = c(0.001, 0.01, 0.1, 1.0),
                          C = seq(0.1, 2, length = 20))

train.control = trainControl(
  method = 'repeatedcv', 
  number = 4
  )


svm.m2 = train(round_winner ~.,
                data = csgo_round_ds,
                method = 'svmPoly',
                trControl = train.control,
                tuneGrid = search.grid)

# results for the best model
confusionMatrix(svm.m2)


#save model
saveRDS(svm.m2, 'svm.m2.rds')


# read in saved model
svm.m2 = readRDS('svm.m2.rds')


```

##Random Forest

```{r}

search.grid = expand.grid(.mtry = (1:5)) 

train.control = trainControl(
  method = 'repeatedcv', 
  number = 4
  )


rf.m1 = train(round_winner ~.,
              data = csgo_round_ds,
              method = 'rf',
              metric = 'Accuracy',
              trControl = train.control,
              tuneGrid = search.grid)



# results for the best model
confusionMatrix(rf.m1)

```


###the k-NN algorithm

```{r}
# odd numbers so we don't have ties
search.grid = expand.grid(k = seq(5, 25, 2)) 

# set up 3-fold cross validation 10 times
train.control = trainControl(
  method = 'repeatedcv', 
  number = 3,
  repeats = 2
  )#Keep this unchanged throughout hw7

# train model
knn = train(round_winner ~ .,
  data = csgo_round_ds,
  method = 'knn',
  trControl = train.control,
  tuneGrid = search.grid
  )

# results for the best model
confusionMatrix(knn)

```


##decision tree
```{r}
### No feature engineering

## build up a default C4.5 model
m = J48(round_winner ~ ., data = csgo_round_ds)

## use cross-validation tech to evaluate the model
e = evaluate_Weka_classifier(m, numFolds = 5, seed = 9, class = TRUE)

## show the performance
print(paste('accuracy: ', e$details['pctCorrect']))

if(require('party', quietly = TRUE)) plot(m)

```


```{r}
##Finding features
info<-information.gain(round_winner~., data = csgo_round)#find the importance attributes
info<- cbind(attributes = rownames(info), info)#make index names into a column 
myVars = c('t_armor', 't_helmets', 't_rifles', 'ct_armor', 't_grenades', 'ct_defuse_kits', 'ct_helmets','ct_rifles','ct_grenades','t_pistols','t_snipers','ct_snipers', 'round_winner')


csgo_round_ds.new = csgo_round_ds[myVars]
#csgo_round_ds.new = csgo_round_ds[setdiff(myVars, 'round_winner')]  #for testing no need


## use some parameters, such as minimum number of objects in leaves and confidence factor
m = J48(round_winner ~ ., data = csgo_round_ds.new, control = Weka_control(U = FALSE, M = 2, C = 0.5))

## evaluate the results
e = evaluate_Weka_classifier(m, numFolds = 5, seed = 9, class = TRUE)

print(paste('accuracy: ', e$details['pctCorrect']))

if(require('party', quietly = TRUE)) plot(m)

```






```{r}
##tuning parameters tree 

C.values = c(0.01,0.05,0.10,0.15,0.20,0.25,0.30,0.35,0.40,0.45,0.5)
M.values = c(2,3,4,5,6,7,8,9,10)

## variable to record the best model
best.performance = 0.0
best.c = 0.0
best.m = 0.0

for (i in 1:length(C.values)) {
  
  for (j in 1:length(M.values)) {
    
    c.value = C.values[i]
    
    m.value = M.values[j]
    
    m = J48(round_winner ~ ., data = csgo_round_ds, 
             control = Weka_control(U = FALSE, C = c.value, M = m.value))
  
    e = evaluate_Weka_classifier(m,
                                 cost = matrix(c(0,1,1,0), ncol = 2),
                                 numFolds = 5, complexity = TRUE,
                                 seed = 9, class = TRUE)

    if (e$details['pctCorrect'] > best.performance) {
      best.performance = e$details['pctCorrect']
      
      best.c = c.value
      best.m = m.value
    }
    
  }
    
}

print(paste('best accuracy: ', best.performance))
print(paste('best m: ', best.m))
print(paste('best c: ', best.c))
```


```{r}

grid = expand.grid(.M=c(2,3,4,5,6,7,8,9,10), 
                   .C=c(0.01,0.05,0.10,0.15,0.20,0.25,0.30,0.35,0.40,0.45,0.50))

# fit the model
csgo.tree = train(round_winner ~ ., 
                  data=csgo_round_ds, 
                  method='J48',
                  trControl = trainControl(method = 'cv',number = 10),
                  tuneGrid = grid)

plot(csgo.tree$finalModel, uniform=TRUE,
     main='Classification Tree')

confusionMatrix(csgo.tree)


```



```{r}
fit <- rpart(round_winner~., data = csgo_round_ds, method = 'class')
rpart.plot(fit, extra = 106)


t_pred = predict(fit,csgo_round,type="class")
t = csgo_round['round_winner']
confMat <- table(csgo_round$round_winner,t_pred)

accuracy <- sum(diag(confMat))/sum(confMat)
accuracy
```


